# MySQL索引与查询优化
1. [创建索引](#创建索引)
2. [索引维护](#索引维护)
3. [索引与字段选择性](#索引与字段选择性)
4. [联合索引与前缀查询](#联合索引与前缀查询)
5. [长字段上的索引](#长字段上的索引)
6. [索引覆盖扫描](#索引覆盖扫描)
7. [无法使用索引的情况](#无法使用索引的情况)
8. [利用索引排序](#利用索引排序)
9. [如何确定一个查询走没走索引,走了哪个索引?](#如何确定一个查询走没走索引,走了哪个索引)


## <span id='创建索引'>创建索引<span>
* 单列索引`CREATE INDEX idx_test ON tb_name(name);`
* 联合索引`CREATE INDEX idx_test ON tb_name(name, age);`


## <span id='索引维护'>索引维护<span>
* 索引维护由数据库自动完成
* 插入/修改/删除每一个索引行都变成一个内部封装的事务
* 索引越多,事务越长,代价越高
* 索引越多对表的插入和索引字段修改就越慢
* ==**控制表上索引的数量!切忌胡乱添加无用索引**==


## <span id='如何使用索引'>如何使用索引<span>
* 根据WHERE条件使用索引
* 排序ORDER BY,GROUP BY,DISTINCT字段添加索引


## <span id='索引与字段选择性'>索引与字段选择性<span>
* 某个字段其值的重复程度  
	* 如身份证号,无重复,属于选择性极好
	* 如名字,可能有重复,但重复不多,属于选择性较好
	* 如性别,有大量重复,属于选择性很差
* 选择性很差的字段通常不适合创建单列索引
* 联合索引中选择性好的字段应该排在前面


## <span id='联合索引与前缀查询'>联合索引与前缀查询<span>
* 联合索引能为前缀单列,复列查询提供帮助
	* 如`idx_smp(a,b,c)`索引,`where a=?` `where a=? and b=?` `where a=? and c=?`都可以通过索引优化查询
* 合理创建联合索引,避免冗余
	* 如`(a)(a,b)(a,b,c)`三个索引中`(a,b,c)`起到的作用包括`(a)(a,b)`,所以只要建立`(a,b,c)`就可以为查询提供帮助


## <span id='长字段上的索引'>长字段上的索引<span>
* 在非常长的字段上建利索引影响性能
* InnoDB索引单字段(utf8)只能取前767bytes
* 对长字段处理的方法
	* email类:建利前缀索引,如`idx_test(email(30))`去该字段前30个字节做索引
	* 地址类:拆分字段,将省,市,地区,街道分别建立字段,为街道创建索引


## <span id='索引覆盖扫描'>索引覆盖扫描<span>
* 最核心的sql考虑索引覆盖
	* `SELECT name FROM tb_user WHERE userid=?`
	* `KEY IDX_UID_NAME(userid,name)`
* 不需要回表获取name字段,IO最小,效率最高
	* 一般用在用户登陆`name` `password`中


## <span id='无法使用索引的情况'>无法使用索引的情况<span>
* 索引可i额进行数学运算或函数运算
	* 如`where id+1=10` `year(col)<2007`无法使用
	* 改为`where id=10-1` `col>'2007-01-01'`可以使用索引
* 未含符合索引的前缀字段
	* 如`idx_abc(a,b,c)` `where b=? and c=?`无法使用,因为where条件中未含有索引前缀a
* 前缀通配'_'和'%'通配符
	* 如`LIKE '%xxx%'`无法使用,而`LIKE 'xxx%'`可以使用
* where条件中有NOT,<,>,!=
* 字段类型不匹配


## <span id='利用索引排序'>利用索引排序<span>
* `idx_a_b(a,b)`
* 能使用索引帮助排序的查询
	* `order by a`
	* `a=3 order by b`前缀索引a为固定值按b排序
	* `order by a,b`
	* `order by a desc,b desc`a和b同为升序或降序
	* `a>5 order by a`前缀a为一个范围,通过a的排序
* 不能使用索引帮助排序的查询
	* `order by b`不包含前缀索引a
	* `a>5 order by b` `a in(1,3) order by b`通过b排序,前缀a不能为一个范围
	* `order by a asc,b desc`a和b的升降序必须一致,否则无法使用索引


## <span id='如何确定一个查询走没走索引,走了哪个索引'>如何确定一个查询走没走索引,走了哪个索引?<span>
* `explain`是确定一个查询如何走索引最简单有效的方法
	* `explain select * from tb_test;`
* 关注的项目
	* `type`:查询access的方式
	* `key`:本次查询最终选择使用哪个索引,`NULL`为未使用索引
	* `key_len`:选择的索引使用的前缀长度或整个长度
	* `row`:可以理解为查询逻辑读,需要扫描过的数据行数
	* `extra`:额外信息,主要指的是`fetch data`的具体方式,`using where`为回表查询